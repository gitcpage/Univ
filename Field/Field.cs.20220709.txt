using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Windows.UI.Xaml.Media.Imaging; // BitmapImage
using Windows.UI.Xaml.Controls; // Image
using Windows.UI.Xaml; // Thickness
using Windows.UI.Xaml.Media; // Stretch
using Windows.UI.Xaml.Media.Animation; // ObjectAnimationUsingKeyFrames
using Windows.System; //VirtualKey

namespace Univ
{
  internal partial class Field : FieldCommon
  {
    FieldBlock obj_;
    FieldBlock player_;
    FieldBgEx bg_;

    bool player_moving_ = false;
    int moveStep_ = 0;
    int moveDirectionX_ = 0;
    int moveDirectionY_ = 0;

    public Field(FrameTimer frameTimer, Grid monitor)
    {
      s_frameTimer_ = frameTimer;
      s_monitor_ = monitor;

      bg_ = new FieldBgEx();
      //bmpObj_ = UnivLib.BitmapImageFromAssets("char/t5040walkt.png");
      obj_ = new FieldBlock("char/t5040walkt.png");
      player_ = new FieldBlock("char/char1p", FieldBlock.DirectionSlot.DownUp);
    }
    public void Run()
    {
      // 初期化
      bg_.Run();
      AppendXyIndex(0, 1, obj_, "imgObj", "obj", 2);
      player_.Image = AppendXyIndex(0, 0, player_.Bitmap, "imgBox", "box", 2);
      //player_.blockX = kTipXNum / 2 - 1;
      //player_.X = (kTipXNum / 2 - 1) * kTipXSize;
      //player_.blockY = kTipYNum / 2 - 1;
      //player_.Y = (kTipYNum / 2 - 1) * kTipYSize;
      player_.BlockSync(kTipXNum / 2 - 1, kTipYNum / 2 - 1);

      //フレームループ開始
      s_frameTimer_.setTimeOut(FrameOne);
    }
    public void FrameOne(object sender, object e)
    {
      if (s_frameTimer_.FrameCount % 50 == 0)
      {
        bg_.ChangeBg(0);
      }
      else if(s_frameTimer_.FrameCount % 25 == 0)
      {
        bg_.ChangeBg(1);
      }

      //右に延々動くやつ
      obj_.XIndex = s_frameTimer_.FrameCount % kTipXNum;

      //上下に動かせるやつ
      if (!player_moving_)
      {
        /*if (s_frameTimer_.IsKeyDown(VirtualKey.Up))
        { // ↑
          moveDirectionY_ = 1;
          player_moving_ = true;
        }
        else if (s_frameTimer_.IsKeyDown(VirtualKey.Down))
        { // ↓
          moveDirectionY_ = -1;
          player_moving_ = true;
        }*/
        player_moving_ = s_frameTimer_.KeyDirection(out moveDirectionX_, out moveDirectionY_);
      }
      if (player_moving_)
      { // （４）
        if (moveStep_ < kMoveTime-1)
        {
          moveStep_++;
          //player_.Y = player_.blockY * kTipYSize + moveY_ * kMoveYStep * moveStep_;
          bg_.Move(moveDirectionX_ * kMoveXStep, moveDirectionY_ * kMoveYStep);
        }
        else
        {
          //moveStep_++;
          //player_.Y = boxPos_ * kTipYSize + moveY_ * kMoveYStep * moveStep_;
          //player_.blockY += moveY_;
          //player_.Y = player_.blockY * kTipYSize;
          bg_.Move(moveDirectionX_ * kMoveXStep, moveDirectionY_ * kMoveYStep);
          moveStep_ = 0;
          player_moving_ = false;
        }
      }//if (player_moving_)
      /*if (!player_moving_)
      {
        if (s_frameTimer_.IsKeyDown(VirtualKey.Up))
        { // ↑
          if (player_.blockY > 0)
          {
            //boxPos_ -= 1;
            //player_.Y = boxPos_ * kTipYSize;
            moveY_ = -1;
            player_.src = "char/char1p20.png";
            player_moving_ = true;
          }
        }
        else if (s_frameTimer_.IsKeyDown(VirtualKey.Down))
        { // ↓
          if (player_.blockY < kTipYNum - 1)
          {
            //boxPos_ += 1;
            //player_.Y = boxPos_ * kTipYSize;
            moveY_ = 1;
            player_.src = "char/char1p00.png";
            player_moving_ = true;
          }
        }
      }
      if (player_moving_)
      { // （４）
        if (moveStep_ < kMoveTime - 1)
        {
          moveStep_++;
          player_.Y = player_.blockY * kTipYSize + moveY_ * kMoveYStep * moveStep_;
        }
        else
        {
          //moveStep_++;
          //player_.Y = boxPos_ * kTipYSize + moveY_ * kMoveYStep * moveStep_;
          player_.blockY += moveY_;
          player_.Y = player_.blockY * kTipYSize;
          moveStep_ = 0;
          player_moving_ = false;
        }
      }*/
    }
  }
}
